public <T extends OrganizationScoped> T setOrganization(T entity) {
        if (entity == null) {
            throw new IllegalArgumentException("Entity cannot be null");
        }

        UUID organizationId = OrganizationContext.getCurrentOrganizationId();
        Organization organization = entityManager.getReference(Organization.class, organizationId);
        entity.setOrganization(organization);

        log.debug("Organization set on entity: {} - orgId={}",
            entity.getClass().getSimpleName(), organizationId);

        return entity;
    }

    /**
     * Sets organization on an entity, or uses a specific organization ID if provided.
     * Useful for admin operations or bulk imports.
     *
     * @param entity the entity
     * @param organizationId specific organization ID (null to use context)
     * @param <T> entity type
     * @return the entity with organization set
     */
    public <T extends OrganizationScoped> T setOrganization(T entity, UUID organizationId) {
        if (entity == null) {
            throw new IllegalArgumentException("Entity cannot be null");
        }

        UUID orgId = organizationId != null ? organizationId : OrganizationContext.getCurrentOrganizationId();
        Organization organization = entityManager.getReference(Organization.class, orgId);
        entity.setOrganization(organization);

        log.debug("Organization set on entity: {} - orgId={}",
            entity.getClass().getSimpleName(), orgId);

        return entity;
    }

    /**
     * @deprecated Use {@link #setOrganization(OrganizationScoped)}
     */
    @Deprecated
    public <T extends OrganizationScoped> T setOrganizationId(T entity) {
        return setOrganization(entity);
    }

    /**
     * @deprecated Use {@link #setOrganization(OrganizationScoped, UUID)}
     */
    @Deprecated
    public <T extends OrganizationScoped> T setOrganizationId(T entity, UUID organizationId) {
        return setOrganization(entity, organizationId);
    }

    /**
     * Validates that an entity belongs to the current organization.
     * Useful for update/delete operations to prevent cross-organization data manipulation.
     *
     * @param entity the entity to validate
     * @param <T> entity type
     * @throws IllegalStateException if organization IDs don't match
     */
    public <T extends OrganizationScoped> void validateOrganizationMatch(T entity) {
        if (entity == null) {
            throw new IllegalArgumentException("Entity cannot be null");
        }

        UUID currentOrgId = OrganizationContext.getCurrentOrganizationId();
        UUID entityOrgId = entity.getOrganizationId();

        if (entityOrgId == null) {
            throw new IllegalStateException("Entity does not have organization ID set");
        }

        if (!currentOrgId.equals(entityOrgId)) {
            log.error("Organization mismatch: current={}, entity={}, entityType={}",
                currentOrgId, entityOrgId, entity.getClass().getSimpleName());
            throw new IllegalStateException(
                "Entity belongs to different organization. Operation not allowed."
            );
        }

        log.debug("Organization match validated: orgId={}, entityType={}",
            currentOrgId, entity.getClass().getSimpleName());
    }

    /**
     * Checks if an entity belongs to the current organization without throwing exception.
     *
     * @param entity the entity to check
     * @param <T> entity type
     * @return true if entity belongs to current organization
     */
    public <T extends OrganizationScoped> boolean belongsToCurrentOrganization(T entity) {
        if (entity == null || entity.getOrganizationId() == null) {
            return false;
        }

        UUID currentOrgId = OrganizationContext.getCurrentOrganizationIdOrNull();
        if (currentOrgId == null) {
            return false;
        }

        return currentOrgId.equals(entity.getOrganizationId());
    } @Transactional(readOnly = true)
    public List<BonCommandeResponse> getBonCommandesByFournisseur(UUID idFournisseur) {
        log.info("Récupération des bons de commande du fournisseur: {}", idFournisseur);
        List<BonCommande> bonCommandes = bonCommandeRepository.findByIdFournisseur(idFournisseur);
        return bonCommandeMapper.toResponseList(bonCommandes);
    }

    @Transactional(readOnly = true)
    public List<BonCommandeResponse> getBonCommandesByStatut(String statut) {
        log.info("Récupération des bons de commande par statut: {}", statut);
        List<BonCommande> bonCommandes = bonCommandeRepository.findByStatut(statut);
        return bonCommandeMapper.toResponseList(bonCommandes);
    }

    @Transactional(readOnly = true)
    public List<BonCommandeResponse> getBonCommandesByDevise(String devise) {
        log.info("Récupération des bons de commande par devise: {}", devise);
        List<BonCommande> bonCommandes = bonCommandeRepository.findByDevise(devise);
        return bonCommandeMapper.toResponseList(bonCommandes);
    }

    @Transactional(readOnly = true)
    public List<BonCommandeResponse> getBonCommandesByDateCommandeBetween(LocalDate startDate, LocalDate endDate) {
        log.info("Récupération des bons de commande entre {} et {}", startDate, endDate);
        List<BonCommande> bonCommandes = bonCommandeRepository.findByDateCommandeBetween(startDate, endDate);
        return bonCommandeMapper.toResponseList(bonCommandes);
    }

    @Transactional(readOnly = true)
    public List<BonCommandeResponse> getBonCommandesByDateLivraisonBetween(LocalDate startDate, LocalDate endDate) {
        log.info("Récupération des bons de commande avec livraison entre {} et {}", startDate, endDate);
        List<BonCommande> bonCommandes = bonCommandeRepository.findByDateLivraisonPrevueBetween(startDate, endDate);
        return bonCommandeMapper.toResponseList(bonCommandes);
    }

    @Transactional(readOnly = true)
    public List<BonCommandeResponse> getBonCommandesByMontantBetween(BigDecimal minAmount, BigDecimal maxAmount) {
        log.info("Récupération des bons de commande entre {} et {}", minAmount, maxAmount);
        List<BonCommande> bonCommandes = bonCommandeRepository.findByMontantTotalBetween(minAmount, maxAmount);
        return bonCommandeMapper.toResponseList(bonCommandes);
    }

    @Transactional(readOnly = true)
    public List<BonCommandeResponse> getBonCommandesByFournisseurAndStatut(UUID idFournisseur, String statut) {
        log.info("Récupération des bons de commande du fournisseur {} avec statut {}", idFournisseur, statut);
        List<BonCommande> bonCommandes = bonCommandeRepository.findByFournisseurAndStatut(idFournisseur, statut);
        return bonCommandeMapper.toResponseList(bonCommandes);
    }

    @Transactional(readOnly = true)
    public List<BonCommandeResponse> searchBonCommandesByNumero(String numeroCommande) {
        log.info("Recherche des bons de commande par numéro: {}", numeroCommande);
        List<BonCommande> bonCommandes = bonCommandeRepository.findByNumeroCommandeContaining(numeroCommande);
        return bonCommandeMapper.toResponseList(bonCommandes);
    }

    @Transactional(readOnly = true)
    public List<BonCommandeResponse> searchBonCommandesByFournisseur(String nomFournisseur) {
        log.info("Recherche des bons de commande par fournisseur: {}", nomFournisseur);
        List<BonCommande> bonCommandes = bonCommandeRepository.findByNomFournisseurContaining(nomFournisseur);
        return bonCommandeMapper.toResponseList(bonCommandes);
    }

    @Transactional
    public void deleteBonCommande(UUID bonCommandeId) {
        log.info("Suppression du bon de commande: {}", bonCommandeId);

        if (!bonCommandeRepository.existsById(bonCommandeId)) {
            throw new IllegalArgumentException("Bon de commande non trouvé: " + bonCommandeId);
        }

        bonCommandeRepository.deleteById(bonCommandeId);

        // Publier l'événement
        bonCommandeEventProducer.publishBonCommandeDeleted(bonCommandeId);

        log.info("Bon de commande supprimé avec succès: {}", bonCommandeId);
    }

    @Transactional(readOnly = true)
    public BigDecimal getTotalMontantByFournisseur(UUID idFournisseur) {
        log.info("Calcul du montant total des commandes pour le fournisseur: {}", idFournisseur);
        BigDecimal total = bonCommandeRepository.sumMontantByFournisseur(idFournisseur);
        return total != null ? total : BigDecimal.ZERO;
    }

    @Transactional(readOnly = true)
    public BigDecimal getTotalMontantByStatut(String statut) {
        log.info("Calcul du montant total des commandes par statut: {}", statut);
        BigDecimal total = bonCommandeRepository.sumMontantByStatut(statut);
        return total != null ? total : BigDecimal.ZERO;
    }

    @Transactional(readOnly = true)
    public Long countByStatut(String statut) {
        return bonCommandeRepository.countByStatut(statut);
    }

    @Transactional(readOnly = true)
    public Long countByFournisseur(UUID idFournisseur) {
        return bonCommandeRepository.countByFournisseur(idFournisseur);
    }